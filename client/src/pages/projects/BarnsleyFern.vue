<template>
    <CanvasProject title="Barnsley Fern" :setUp="setUp" :update="update">
        <template slot="controls">
            <form class="controls" @submit.prevent>
                <div class="input-container">
                    <label for="renderSpeed">Render Speed</label>
                    <input id="renderSpeed" type="number" name="renderSpeed" v-model="renderSpeed" @change="updateRenderSpeed">
                </div>

                <div class="input-container">
                    <button type="button" @click="reset">Reset</button>
                </div>
            </form>
        </template>

        <template slot="description">
            <p>
                The Barnsley fern is a fractal designed to look like <ExternalLink href="https://en.wikipedia.org/wiki/Asplenium_adiantum-nigrum">black spleenwort</ExternalLink>. The fractal is named for <ExternalLink href="https://en.wikipedia.org/wiki/Michael_Barnsley">Michael Barnsley</ExternalLink>.
            </p>

            <p>
                Starting with an initial coordinate position (on the canvas), the Barnsley fern is generated by probabilistically applying one of several matrix transformations to the current position and making a mark at the current position.
            </p>

            <p>
                The construction rules are as follows:
            </p>

            <p>
                Start with an initial position of (0, 0).
            </p>

            <div class="rule" v-for="rule in rules" :key="rule.generates">
                <p>
                    To generate {{ rule.generates }}, with probability {{ rule.probability }}, use:
                </p>

                <div class="math-block math-row">
                    <span class="variable">f(x, y)</span> <span>=</span>
                    <table class="matrix">
                        <tr class="matrix-row"><td>{{ rule.matrix[0][0].toFixed(2) }}</td><td>{{ rule.matrix[0][1].toFixed(2) }}</td></tr>
                        <tr class="matrix-row"><td>{{ rule.matrix[1][0].toFixed(2) }}</td><td>{{ rule.matrix[1][1].toFixed(2) }}</td></tr>
                    </table>
                    <table class="matrix">
                        <tr class="matrix-row"><td><span class="variable">x</span></td></tr>
                        <tr class="matrix-row"><td><span class="variable">y</span></td></tr>
                    </table>
                    <span>+</span>
                    <table class="matrix">
                        <tr class="matrix-row"><td>{{ rule.constantVector[0].toFixed(2) }}</td></tr>
                        <tr class="matrix-row"><td>{{ rule.constantVector[1].toFixed(2) }}</td></tr>
                    </table>
                </div>
            </div>

            <p>
                Check out the <ExternalLink href="https://en.wikipedia.org/wiki/Barnsley_fern">Wikipedia article</ExternalLink> for more.
            </p>
        </template>
    </CanvasProject>
</template>

<script>
import CanvasProject from "./CanvasProject";
import ExternalLink from "../../components/ExternalLink";

export default {
    name: "BarnsleyFern",
    components: {
        CanvasProject,
        ExternalLink,
    },
    data() {
        return {
            renderSpeed: 75,
            rules: [
                {
                    generates: "the stem",
                    probability: 0.01,
                    matrix: [[0, 0], [0, 0.16]],
                    constantVector: [0, 0],
                },
                {
                    generates: "successively small leaflets",
                    probability: 0.85,
                    matrix: [[0.85, 0.04], [-0.04, 0.85]],
                    constantVector: [0, 1.6],
                },
                {
                    generates: "the largest left-hand leaflet",
                    probability: 0.07,
                    matrix: [[0.2, -0.26], [0.23, 0.22]],
                    constantVector: [0, 1.6],
                },
                {
                    generates: "the largest right-hand leaflet",
                    probability: 0.07,
                    matrix: [[-0.15, 0.28], [0.26, 0.24]],
                    constantVector: [0, 0.44],
                },
            ]
        }
    },
    methods: {
        setUp(canvas) {
            this.canvas = canvas;
            this.ctx = this.canvas.getContext("2d");
            this.color = "#0c9c0c";
            this.x = 0;
            this.y = 0;
        },

        reset() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.setUp(this.canvas);
        },

        update() {
            this.ctx.fillStyle = this.color;
            this.ctx.strokeStyle = this.color;

            const imageDimensions = this.getImageDimensions();

            for (let i = 0; i < (this.renderSpeed || 0); i++) {
                this.drawPixel(this.x, this.y, imageDimensions);

                const { nextX, nextY } = getNextPosition(this.x, this.y);
                this.x = nextX;
                this.y = nextY;
            }
        },

        getImageDimensions() {
            const ratio = 1;
            const ratioWidth = this.canvas.height * ratio;
            const ratioHeight = this.canvas.width / ratio;

            let imgWidth, imgHeight;
            if (this.canvas.width > ratioWidth) {
                imgWidth = ratioWidth;
                imgHeight = this.canvas.height;
            } else {
                imgWidth = this.canvas.width;
                imgHeight = ratioHeight;
            }

            const horizontalPadding = (this.canvas.width - imgWidth) / 2;
            const verticalPadding = (this.canvas.height - imgHeight) / 2;

            return { imgWidth, imgHeight, horizontalPadding, verticalPadding }
        },

        drawPixel(x, y, { imgWidth, imgHeight, horizontalPadding, verticalPadding }) {
            this.ctx.fillRect(
                imgWidth * (x + 3) / 6 + horizontalPadding,
                imgHeight - imgHeight * ((y + 2) / 14) + verticalPadding,
                1,
                1,
            );
        },
    }
}

function getNextPosition(x, y) {
    const rand = Math.random();

    let matrix, constantVector;

    if (rand < 0.01) {
        matrix = [
            [0, 0],
            [0, 0.16],
        ];
        constantVector = [0, 0];
    } else if (rand < 0.86) {
        matrix = [
            [0.85, 0.04],
            [-0.04, 0.85],
        ];
        constantVector = [0, 1.6];
    } else if (rand < 0.93) {
        matrix = [
            [0.2, -0.26],
            [0.23, 0.22],
        ];
        constantVector = [0, 1.6];
    } else {
        matrix = [
            [-0.15, 0.28],
            [0.26, 0.24],
        ];
        constantVector = [0, 0.44];
    }

    let [nextX, nextY] = matrixMultiply(
        matrix,
        [x, y],
    );

    [nextX, nextY] = addVectors(
        [nextX, nextY],
        constantVector,
    );

    return { nextX, nextY };
}

function matrixMultiply(matrix, vector) {
    return [
        matrix[0][0] * vector[0] + matrix[0][1] * vector[1],
        matrix[1][0] * vector[0] + matrix[1][1] * vector[1],
    ]
}

function addVectors(v1, v2) {
    return [
        v1[0] + v2[0],
        v1[1] + v2[1],
    ]
}

</script>


<style scoped>
    .rule:last-of-type {
        margin-bottom: 2rem;
    }

    .math-block .variable {
        font-style: italic;
    }

    .math-row {
        display: flex;
        flex-flow: row;
        align-items: center;
    }

    .math-row > * {
        margin-right: .5rem;
        display: inline-block;
    }

    .matrix {
        --border-width: 1px;
        border: var(--border-width) solid var(--color);
        position: relative;
        --border-hook-size: 3px;
    }

    .matrix::before,
    .matrix::after {
        content: "";
        width: calc(100% - 2 * var(--border-hook-size));
        height: var(--border-width);
        background-color: var(--background-color);
        display: block;
        position: absolute;
        left: var(--border-hook-size);
    }

    .matrix::before {
        bottom: calc(-1 * var(--border-width));
    }

    .matrix::after {
        top: calc(-1 * var(--border-width));
    }

    .matrix td {
        padding: .1rem .15rem;
    }
</style>