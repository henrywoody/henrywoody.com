---
import Layout from "../../layouts/Layout.astro";
import CanvasProject from "../../components/CanvasProject.astro";
import ExternalLink from "../../components/ExternalLink.astro";
---

<Layout title="One Dimensional Cellular Automata | Henry Woody">
	<CanvasProject title="One Dimensional Cellular Automata">
		<form slot="controls" class="controls">
			<div class="input-container">
				<label for="rule">Rule</label>
				<input id="rule" type="number" name="rule" max="255" min="0" />
			</div>

			<div class="input-container">
				<label for="random-rules">Random Rules</label>
				<input id="random-rules" type="checkbox" name="random-rules" checked />
			</div>

			<div class="input-container">
				<label for="speed">Speed</label>
				<input id="speed" type="range" name="speed" max="10" min="1" value="6" />
				<input class="range-standin" type="number" name="speed-standin" max="10" min="1" value="6" />
			</div>

			<div class="input-container">
				<label for="alive-color">Alive Color</label>
				<input type="color" name="alive-color" id="alive-color" />
			</div>

			<div class="input-container">
				<label for="dead-color">Dead Color</label>
				<input type="color" name="dead-color" id="dead-color" />
			</div>

			<div class="input-container">
				<button type="button" id="reset-btn">Reset</button>
			</div>
		</form>

		<Fragment slot="description">
			<p>
				A one dimensional cellular automaton is a discrete mathematical model for simulating complex systems. The
				environment is a linear strip of cells where each cell can have one of several possible states. The simplest
				interesting example, is a binary state cellular automaton, for example the states might be interpreted as alive
				and dead. The state of each cell in the next stage, or time step, is determined by its current state and the
				states of the cells on either side of it.
			</p>

			<p>
				How the configuration of the three cells (self and neighbors) impact a given cell depends on the selected rule.
				A rule is a mapping from current cell configurations to a single cell state. For example, a rule might specify
				that a cell is alive in the next stage if it and its neighbors are all currently alive and is dead otherwise.
			</p>

			<h2>Elementary Cellular Automata</h2>

			<p>
				An elementary cellular automaton is a binary state (e.g. 0 and 1), one dimenstional cellular automaton. With two
				possible states for each cell and three "parent" cells, there are 2<sup>3</sup> possible parent configurations. Here
				they are:
			</p>

			<p class="parent-configs">
				<span>111</span><span>110</span><span>101</span><span>100</span><span>011</span><span>010</span><span>001</span
				><span>000</span>
			</p>

			<p>
				Each of these configurations can lead to a live cell or dead cell. Thus there are 2<sup>2<sup>3</sup></sup> = 256
				rules for elementary cellular automata. Each rule is basically just a number that, when written in 8-bit binary form,
				determines how the parent configurations map to states for each cells. For example, rule 30 (or 00011110), looks like
				this:
			</p>

			<p class="parent-configs">
				<span>111</span><span>110</span><span>101</span><span>100</span><span>011</span><span>010</span><span>001</span
				><span>000</span>
			</p>
			<p class="child-configs">
				<span>0</span><span>0</span><span>0</span><span>1</span><span>1</span><span>1</span><span>1</span><span>0</span>
			</p>

			<p>
				Where the top row is the parent configuration and the bottom row is the state of the cell with that parent
				configuration in the next stage.
			</p>

			<p>
				See this <ExternalLink href="http://mathworld.wolfram.com/ElementaryCellularAutomaton.html"
					>WolframMathWorld article</ExternalLink
				> for more.
			</p>
		</Fragment>
	</CanvasProject>
</Layout>

<script>
	import { isDarkModeOn } from "../../utilities/theme";

	const canvas = document.querySelector("canvas")!;
	const ctx = canvas.getContext("2d")!;
	const ruleInput = document.getElementById("rule") as HTMLInputElement;
	const randomRulesInput = document.getElementById("random-rules") as HTMLInputElement;
	const speedInput = document.getElementById("speed") as HTMLInputElement;
	const speedStandinInput = document.querySelector("input[name='speed-standin']") as HTMLInputElement;
	const aliveColorInput = document.getElementById("alive-color") as HTMLInputElement;
	const deadColorInput = document.getElementById("dead-color") as HTMLInputElement;
	const resetBtn = document.getElementById("reset-btn")!;

	if (isDarkModeOn()) {
		aliveColorInput.value = "#ffffff";
		deadColorInput.value = "#333333";
	} else {
		aliveColorInput.value = "#000000";
		deadColorInput.value = "#ffffff";
	}

	const cellSize = 5;
	const ruleChangeFrequency = 200;
	let grid: number[][] = [];
	let stageCounter = 0;
	let tickCounter = 0;

	// Sync speed inputs
	speedInput.addEventListener("input", () => {
		speedStandinInput.value = speedInput.value;
	});
	speedStandinInput.addEventListener("input", () => {
		speedInput.value = speedStandinInput.value;
	});

	function resizeCanvas() {
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}

	function setUp() {
		resizeCanvas();
		grid = [];
		stageCounter = 0;
		tickCounter = 0;

		const goodStartingRules = ["30", "57", "150", "182"];
		ruleInput.value = goodStartingRules[Math.floor(Math.random() * goodStartingRules.length)];

		setFirstRow();
	}

	function update() {
		const speed = Math.min(Math.max(Number(speedInput.value), 1), 10);
		tickCounter = (tickCounter + 1) % (11 - speed);
		if (tickCounter === 0) {
			stageCounter = (stageCounter + 1) % ruleChangeFrequency;
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			generateRow();
			maybeTrimRows();
			draw();
			maybeChangeRule();
		}
	}

	function run() {
		update();
		window.requestAnimationFrame(run);
	}

	function setFirstRow() {
		const numCells = getNumCellsPerRow();
		const row = Array(numCells).fill(0);
		row[Math.floor(numCells / 2)] = 1;
		grid.push(row);
	}

	function generateRow() {
		const numCells = getNumCellsPerRow();
		const prevRow = grid.slice(-1)[0];
		const nextRow = Array(numCells).fill(0);
		const ruleMap = getRuleMap();
		for (let i = 0; i < prevRow.length; i++) {
			const parentConfig = getParentConfig(i, prevRow);
			nextRow[i] = ruleMap[parentConfig];
		}
		grid.push(nextRow);
	}

	function getRuleMap(): Record<string, number> {
		const parentConfigs = Array(8)
			.fill(0)
			.map((_, i) => toBinary(i, 3))
			.reverse();
		const rule = Math.min(Math.max(Number(ruleInput.value), 0), 255);
		const outcomes = toBinary(rule, 8, true) as number[];
		const ruleMap: Record<string, number> = {};
		for (let i = 0; i < parentConfigs.length; i++) {
			ruleMap[parentConfigs[i] as string] = outcomes[i];
		}
		return ruleMap;
	}

	function getNumCellsPerRow() {
		return Math.floor(canvas.width / cellSize);
	}

	function getParentConfig(i: number, prevRow: number[]) {
		let parentConfig: number[];
		switch (i) {
			case 0:
				parentConfig = [0].concat(prevRow.slice(0, 2));
				break;
			case prevRow.length - 1:
				parentConfig = prevRow.slice(-2).concat([0]);
				break;
			default:
				parentConfig = prevRow.slice(i - 1, i + 2);
		}
		return parentConfig.join("");
	}

	function maybeTrimRows() {
		const numRows = Math.floor(canvas.height / cellSize);
		if (grid.length > numRows) {
			const numToTrim = grid.length - numRows;
			grid = grid.slice(numToTrim);
		}
	}

	function maybeChangeRule() {
		if (randomRulesInput.checked && stageCounter === 0) {
			ruleInput.value = Math.floor(Math.random() * 256).toString();
		}
	}

	function draw() {
		const aliveColor = aliveColorInput.value;
		const deadColor = deadColorInput.value;
		for (let i = 0; i < grid.length; i++) {
			for (let j = 0; j < grid.slice(-1)[0].length; j++) {
				const y = i * cellSize;
				const x = j * cellSize;
				const cellState = grid[i][j];
				const color = cellState === 1 ? aliveColor : deadColor;
				if (!color) continue;
				ctx.fillStyle = color;
				ctx.fillRect(x, y, cellSize, cellSize);
			}
		}
	}

	function toBinary(num: number, length: number, asArray?: boolean): string | number[] {
		const binary = num.toString(2);
		const padding = "0".repeat(length - binary.length);
		const fullBinary = padding + binary;
		if (asArray) {
			return fullBinary.split("").map((e) => Number(e));
		}
		return fullBinary;
	}

	resetBtn.addEventListener("click", () => setUp());
	window.addEventListener("resize", resizeCanvas);
	setUp();
	run();
</script>

<style>
	button {
		margin-top: 0.5rem;
	}

	.parent-configs,
	.child-configs {
		display: flex;
		flex-flow: row;
		justify-content: space-between;
	}

	.child-configs {
		padding: 0 0.5rem;
	}
</style>
