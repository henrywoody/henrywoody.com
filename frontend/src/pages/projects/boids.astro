---
import Layout from "../../layouts/Layout.astro";
import CanvasProject from "../../components/CanvasProject.astro";
import ExternalLink from "../../components/ExternalLink.astro";
---

<Layout title="Boids | Henry Woody">
	<CanvasProject title="Boids">
		<form slot="controls" class="controls">
			<div class="input-container">
				<label for="numBoids">Population</label>
				<input id="numBoids" type="number" name="numBoids" value="100" />
			</div>

			<div class="input-container">
				<label for="flocking">Flocking</label>
				<input type="checkbox" name="flocking" id="flocking" checked />
			</div>

			<div class="input-container">
				<label for="colors">Colors</label>
				<input type="checkbox" name="colors" id="colors" />
			</div>
		</form>

		<Fragment slot="description">
			<p>
				Boids (bird-oids) are artificial creatures that simulate the flocking behavior of natural birds. They were
				originally described by Craig W. Reynolds in a <ExternalLink
					href="http://www.cs.toronto.edu/~dt/siggraph97-course/cwr87/">1987 paper</ExternalLink
				> on simulating aggregate behavior of groups of individuals.
			</p>

			<p>
				Each boid independently decides how to move according to the following set of rules:

				<ol>
					<li>Move toward the center of mass of the other boids within some neighborhood</li>
					<li>Keep a small distance from other boids to avoid collisions</li>
					<li>Try to match the velocity of nearby boids</li>
				</ol>
			</p>

			<p>
				I've added the 'colors' flocking rule here, which incorporates chromatic distance, in addition to spacial, when
				each boids considers their neighbors. So in order to be considered a neighbor, a boid must be relatively close
				spacially and have a similar color. Basically boids will only flock with similarly colored boids if 'colors' is
				on.
			</p>
		</Fragment>
	</CanvasProject>
</Layout>

<script>
	const canvas = document.querySelector("canvas")!;
	const ctx = canvas.getContext("2d")!;
	const numBoidsInput = document.getElementById("numBoids") as HTMLInputElement;
	const flockingInput = document.getElementById("flocking") as HTMLInputElement;
	const colorsInput = document.getElementById("colors") as HTMLInputElement;

	let requestID: number | null = null;
	const maxSpeed = 2;
	let boids: Boid[] = [];

	function resizeCanvas() {
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}

	function setUp() {
		resizeCanvas();
		boids = [];
		addBoids(100);
	}

	function run() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		const isFlockingOn = flockingInput.checked;
		const areColorsOn = colorsInput.checked;
		for (const boid of boids) {
			boid.updatePosition(boids, canvas, isFlockingOn, areColorsOn);
			boid.draw(ctx);
		}
		requestID = window.requestAnimationFrame(run);
	}

	function addBoids(num: number) {
		for (let i = 0; i < num; i++) {
			const color = getRandomColor();
			const initPosition: [number, number] = [Math.random() * canvas.width, Math.random() * canvas.height];
			const initVelocity: [number, number] = [Math.random() * (maxSpeed - 1) + 1, Math.random() * 2 * Math.PI];
			boids.push(new Boid(color, initPosition, initVelocity));
		}
	}

	function getRandomColor(rRange = [0, 255], gRange = [0, 255], bRange = [0, 255]) {
		return (
			"#" +
			[rRange, gRange, bRange]
				.map((e) => {
					return (Math.round(Math.random() * (e[1] - e[0])) + e[0]).toString(16);
				})
				.map((e) => {
					return e.length < 2 ? "0" + e : e;
				})
				.join("")
		);
	}

	numBoidsInput.addEventListener("change", () => {
		const target = Number(numBoidsInput.value);
		if (target > boids.length) {
			addBoids(target - boids.length);
		} else if (boids.length > target) {
			boids = boids.slice(boids.length - target);
		}
	});

	class Boid {
		color: string;
		position: [number, number];
		velocity: [number, number];
		size = 3;
		beakLength = 1.5 * 3;
		neighborhoodDistance = 30;
		colorTolerance = 90;
		avoidDistance = 3 * 3;
		thisSpeedInfluence = 0;
		thisAngleInfluence = 1;
		centerOfMassInfluence = 0.75;
		avoidSpeedInfluence = 1;
		avoidAngleInfluence = 1;
		neighborSpeedInfluence = 100;
		neighborAngleInfluence = 100;

		constructor(color: string, initPosition: [number, number], initVelocity: [number, number]) {
			this.color = color;
			this.position = initPosition;
			this.velocity = initVelocity || [0, 0];
		}

		updatePosition(otherBoids: Boid[], canvas: HTMLCanvasElement, isFlockingOn: boolean, areColorsOn: boolean) {
			this.updateVelocity(otherBoids, isFlockingOn, areColorsOn);
			this.position[0] += this.velocity[0] * Math.cos(this.velocity[1]);
			this.position[1] += this.velocity[0] * Math.sin(this.velocity[1]);
			this.position[0] = (this.position[0] + canvas.width) % canvas.width;
			this.position[1] = (this.position[1] + canvas.height) % canvas.height;
		}

		updateVelocity(otherBoids: Boid[], isFlockingOn: boolean, areColorsOn: boolean) {
			const closeBoids = this.getNeighborsAndDistances(otherBoids);
			const boidsToAvoid = closeBoids.filter((e) => e[1] <= this.avoidDistance);
			this.checkAndHandleCollisions(boidsToAvoid);

			const neighborDistances = closeBoids.filter((e) => {
				const colorDistance = getColorDistanceBetween(this.color, e[0].color);
				return !areColorsOn || colorDistance < this.colorTolerance;
			});
			if (!neighborDistances.length) return;

			const angleToCenter = isFlockingOn ? this.getAngleToCenterOfMass(neighborDistances) : this.velocity[1];
			const avoidVelocity = this.getAvoidVelocity(boidsToAvoid);
			const aveVelocity = isFlockingOn ? this.getAveVelocity(neighborDistances) : this.velocity;

			let speedSum = this.thisSpeedInfluence * this.velocity[0] + this.neighborSpeedInfluence * aveVelocity[0];
			let speedWeightSum = this.thisSpeedInfluence + this.neighborSpeedInfluence;

			const angles = [this.velocity[1], aveVelocity[1], angleToCenter];
			const angleWeights = [this.thisAngleInfluence, this.neighborAngleInfluence, this.centerOfMassInfluence];
			if (avoidVelocity) {
				speedSum += this.avoidSpeedInfluence * aveVelocity[0];
				speedWeightSum += this.avoidSpeedInfluence;
				angles.push(aveVelocity[1] + Math.PI);
				angleWeights.push(this.avoidAngleInfluence);
			}

			const randAngle = Math.random() * 0.1 - 0.05;
			const newSpeed = speedSum / speedWeightSum;
			const newAngle = (getAveAngle(angles, angleWeights) + randAngle + 2 * Math.PI) % (2 * Math.PI);
			this.velocity = [newSpeed, newAngle];
		}

		getNeighborsAndDistances(otherBoids: Boid[]): [Boid, number][] {
			return otherBoids.reduce((a: [Boid, number][], e) => {
				const distance = getDistanceBetween(this.position, e.position);
				const isNeighbor = distance <= this.neighborhoodDistance && e !== this;
				return isNeighbor ? a.concat([[e, distance]]) : a;
			}, []);
		}

		getAngleToCenterOfMass(neighborDistances: [Boid, number][]) {
			const positionSum = neighborDistances.reduce(
				(a, e) => {
					return [a[0] + e[0].position[0], a[1] + e[0].position[1]];
				},
				[0, 0],
			);
			const center = positionSum.map((e) => e / neighborDistances.length);
			return getAngleBetween(this.position, center);
		}

		getAvoidVelocity(boidsToAvoid: [Boid, number][]) {
			if (!boidsToAvoid.length) return;
			return this.getAveVelocity(boidsToAvoid);
		}

		getAveVelocity(neighborDistances: [Boid, number][]): [number, number] {
			let speedSum = 0;
			let neighborAngles: number[] = [];
			for (const neighborDist of neighborDistances) {
				const boid = neighborDist[0];
				speedSum += boid.velocity[0];
				neighborAngles.push(boid.velocity[1]);
			}
			const speed = speedSum / neighborDistances.length;
			const angle = getAveAngle(neighborAngles);
			return [speed, angle];
		}

		checkAndHandleCollisions(boidsToAvoid: [Boid, number][]) {
			for (const [otherBoid, distance] of boidsToAvoid) {
				if (distance <= this.size + otherBoid.size) {
					this.bounceBack(otherBoid);
				}
			}
		}

		bounceBack(otherBoid: Boid) {
			const bounceDist = 0.2;
			this.position[0] += otherBoid.position[0] - this.position[0] > 0 ? -bounceDist : bounceDist;
			this.position[1] += otherBoid.position[1] - this.position[1] > 0 ? -bounceDist : bounceDist;
			otherBoid.position[0] += this.position[0] - otherBoid.position[0] > 0 ? -bounceDist : bounceDist;
			otherBoid.position[1] += this.position[1] - otherBoid.position[1] > 0 ? -bounceDist : bounceDist;
		}

		draw(ctx: CanvasRenderingContext2D) {
			ctx.fillStyle = this.color;
			ctx.strokeStyle = this.color;
			ctx.beginPath();
			ctx.arc(this.position[0], this.position[1], this.size, 0, 2 * Math.PI);
			ctx.fill();
			ctx.closePath();
			ctx.beginPath();
			ctx.moveTo(this.position[0], this.position[1]);
			ctx.lineTo(
				this.beakLength * Math.cos(this.velocity[1]) + this.position[0],
				this.beakLength * Math.sin(this.velocity[1]) + this.position[1],
			);
			ctx.stroke();
		}
	}

	function getAngleBetween(a: number[], b: number[]) {
		const dx = b[0] - a[0];
		const dy = b[1] - a[1];
		return (Math.atan2(dy, dx) + 2 * Math.PI) % (2 * Math.PI);
	}

	function getDistanceBetween(a: number[], b: number[]) {
		const dx = b[0] - a[0];
		const dy = b[1] - a[1];
		return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
	}

	function getColorDistanceBetween(a: string, b: string) {
		const aColor = a.slice(1);
		const bColor = b.slice(1);
		let diff = 0;
		for (let i = 0; i < 3; i++) {
			const aComp = parseInt(aColor.slice(2 * i, 2 * (i + 1)), 16);
			const bComp = parseInt(bColor.slice(2 * i, 2 * (i + 1)), 16);
			diff += Math.abs(aComp - bComp);
		}
		return diff;
	}

	function getAveAngle(angles: number[], weights?: number[]) {
		if (angles.length === 1) return angles[0];
		weights = weights || Array(angles.length).fill(1);
		let xSum = 0;
		let ySum = 0;
		for (let i = 0; i < angles.length; i++) {
			xSum += Math.cos(angles[i]) * weights[i];
			ySum += Math.sin(angles[i]) * weights[i];
		}
		const weightSum = weights.reduce((a, e) => a + e);
		const xAve = xSum / weightSum;
		const yAve = ySum / weightSum;
		return Math.atan2(yAve, xAve);
	}

	window.addEventListener("resize", resizeCanvas);
	setUp();
	run();
</script>
