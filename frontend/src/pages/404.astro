---
import Layout from "../layouts/Layout.astro";
import AsteroidsLeaderboard from "../components/AsteroidsLeaderboard.astro";
---

<Layout title="Asteroids | Henry Woody">
	<main>
		<h1>404: Not Found</h1>

		<div id="asteroids-container">
			<span class="score" id="score-display">Score: 0</span>
			<canvas></canvas>
			<div class="game-over" id="game-over" style="display:none;">
				<span class="game-over-message">Game Over</span>
				<div id="leaderboard-container"></div>
				<button id="play-again-btn">Play Again?</button>
			</div>
			<input class="focus-attractor" id="focus-attractor" />
		</div>
	</main>
</Layout>

<script>
	import { isDarkModeOn } from "../utilities/theme";

	const container = document.getElementById("asteroids-container")!;
	const canvas = container.querySelector("canvas")!;
	const ctx = canvas.getContext("2d")!;
	const scoreDisplay = document.getElementById("score-display")!;
	const gameOverEl = document.getElementById("game-over")!;
	const leaderboardContainer = document.getElementById("leaderboard-container")!;
	const playAgainBtn = document.getElementById("play-again-btn")!;
	const focusAttractor = document.getElementById("focus-attractor") as HTMLInputElement;

	let gameOver = false;
	let score = 0;
	let time = 0;
	let ship: Ship;
	let bullets: Bullet[] = [];
	let asteroids: Asteroid[] = [];
	let xMin: number, xMax: number, yMin: number, yMax: number;

	function resizeCanvas() {
		canvas.width = window.innerWidth;
		const headerHeight = (document.querySelector(".header-bar") as HTMLElement | undefined)?.offsetHeight || 0;
		canvas.height = window.innerHeight - headerHeight;

		const boundaryExtension = 100;
		xMin = -boundaryExtension;
		xMax = canvas.width + boundaryExtension;
		yMin = -boundaryExtension;
		yMax = canvas.height + boundaryExtension;
	}

	function reset() {
		resizeCanvas();
		const middleOfCanvas: [number, number] = [canvas.width / 2, canvas.height / 2];
		ship = new Ship(middleOfCanvas, addBullet);
		bullets = [];
		asteroids = [];
		gameOver = false;
		score = 0;
		time = 0;
		scoreDisplay.textContent = "Score: 0";
		scoreDisplay.style.display = "";
		gameOverEl.style.display = "none";
		leaderboardContainer.innerHTML = "";
		focusAttractor.focus();
		focusAttractor.blur();
	}

	function run() {
		update();
		draw();
		window.requestAnimationFrame(run);
	}

	function update() {
		const color = isDarkModeOn() ? "#ffffff" : "#333333";
		ctx.fillStyle = color;
		ctx.strokeStyle = color;

		ship.update(canvas.width, canvas.height);
		for (const bullet of bullets) bullet.update();
		for (const asteroid of asteroids) asteroid.update();
		removeOutOfBoundsObjects();
		makeRandomAsteroids();
		checkCollisions();
		removeInactiveObjects();

		if (!gameOver) time++;
	}

	function addBullet(bullet: Bullet) {
		bullets.push(bullet);
	}

	function makeRandomAsteroids() {
		const asteroidCreationProb = Math.log(Math.log(time)) * 0.008;
		if (Math.random() < asteroidCreationProb) {
			const numToCreate = Math.floor(Math.random() * 3) + 1;
			for (let i = 0; i < numToCreate; i++) {
				let position: [number, number], direction: number;
				const rand = Math.random();
				if (rand < 0.25) {
					position = [xMin, Math.random() * yMax];
					direction = Math.random() * Math.PI + Math.PI;
				} else if (rand < 0.5) {
					position = [xMax, Math.random() * yMax];
					direction = -1 * Math.random() * Math.PI - Math.PI;
				} else if (rand < 0.75) {
					position = [Math.random() * xMax, yMin];
					direction = Math.random() * Math.PI;
				} else {
					position = [Math.random() * xMax, yMax];
					direction = -1 * Math.random() * Math.PI;
				}
				asteroids.push(new Asteroid(position, direction));
			}
		}
	}

	function removeOutOfBoundsObjects() {
		const filterFunc = (e: { position: [number, number] }) => {
			const inXBounds = xMin <= e.position[0] && e.position[0] <= xMax;
			const inYBounds = yMin <= e.position[1] && e.position[1] <= yMax;
			return inXBounds && inYBounds;
		};
		bullets = bullets.filter(filterFunc);
		asteroids = asteroids.filter(filterFunc);
	}

	function checkCollisions() {
		if (!gameOver) checkShipAsteroidCollisions();
		checkBulletAsteroidCollisions();
	}

	function checkShipAsteroidCollisions() {
		for (const asteroid of asteroids) {
			const distance = getDistanceBetween(asteroid.position, ship.position);
			if (distance <= asteroid.size + ship.size / 2) {
				ship.crash();
				endGame();
				break;
			}
		}
	}

	function checkBulletAsteroidCollisions() {
		const newAsteroids: Asteroid[] = [];
		for (const bullet of bullets) {
			for (const asteroid of asteroids) {
				const distance = getDistanceBetween(asteroid.position, bullet.position);
				if (distance <= asteroid.size + bullet.size) {
					bullet.hit();
					newAsteroids.push(...asteroid.split());
					score += asteroid.score;
					scoreDisplay.textContent = `Score: ${score}`;
				}
			}
		}
		asteroids.push(...newAsteroids);
	}

	function removeInactiveObjects() {
		const filterFunc = (e: { isActive: boolean }) => e.isActive;
		bullets = bullets.filter(filterFunc);
		asteroids = asteroids.filter(filterFunc);
	}

	function endGame() {
		gameOver = true;
		scoreDisplay.style.display = "none";
		gameOverEl.style.display = "";
		// Build leaderboard dynamically
		buildLeaderboard();
	}

	async function buildLeaderboard() {
		const numScores = 10;
		try {
			const response = await fetch(`/api/asteroids_scores?limit=${numScores}`);
			const highScores: { score: number; name: string }[] = await response.json();

			let displayScores = [...highScores];
			let isNewHighScore = false;

			if (highScores.length && score > highScores[highScores.length - 1].score) {
				isNewHighScore = true;
				let insertIndex = 0;
				if (score <= highScores[0].score) {
					for (let i = highScores.length - 1; i >= 0; i--) {
						if (highScores[i].score >= score) {
							insertIndex = i + 1;
							break;
						}
					}
				}
				displayScores.splice(insertIndex, 0, { score, name: "$this" });
				if (displayScores.length > numScores) displayScores.pop();
			} else if (highScores.length < numScores && score > 0) {
				isNewHighScore = true;
				displayScores.push({ score, name: "$this" });
			}

			leaderboardContainer.innerHTML = "";
			const wrapper = document.createElement("div");
			wrapper.className = "leaderboard";

			const scoreInfo = document.createElement("div");
			scoreInfo.className = "score-info";
			if (isNewHighScore) {
				const nhsSpan = document.createElement("span");
				nhsSpan.className = "new-high-score";
				nhsSpan.textContent = "New High Score!";
				scoreInfo.appendChild(nhsSpan);
			}
			const gsSpan = document.createElement("span");
			gsSpan.className = "game-over-score";
			gsSpan.textContent = `Score: ${score}`;
			scoreInfo.appendChild(gsSpan);
			wrapper.appendChild(scoreInfo);

			if (displayScores.length) {
				const label = document.createElement("span");
				label.textContent = "Leaderboard";
				label.style.textAlign = "center";
				label.style.display = "block";
				wrapper.appendChild(label);

				const ol = document.createElement("ol");
				let playerName = "";
				let scoreWasPosted = false;

				for (const hs of displayScores) {
					const li = document.createElement("li");
					const span = document.createElement("span");

					if (hs.name === "$this") {
						const sSpan = document.createElement("span");
						sSpan.textContent = String(hs.score);
						const form = document.createElement("form");
						const input = document.createElement("input");
						input.type = "text";
						input.size = 3;
						input.maxLength = 3;
						input.addEventListener("input", () => {
							playerName = input.value.toUpperCase();
							input.value = playerName;
						});
						form.addEventListener("submit", async (e) => {
							e.preventDefault();
							if (!scoreWasPosted) {
								await fetch("/api/asteroids_scores", {
									method: "POST",
									headers: { "Content-Type": "application/json" },
									body: JSON.stringify({ score, name: playerName }),
								});
								scoreWasPosted = true;
								input.readOnly = true;
							}
						});
						form.appendChild(input);
						span.appendChild(sSpan);
						span.appendChild(form);
						requestAnimationFrame(() => input.focus());
					} else {
						const sSpan = document.createElement("span");
						sSpan.textContent = String(hs.score);
						const nSpan = document.createElement("span");
						nSpan.textContent = hs.name;
						span.appendChild(sSpan);
						span.appendChild(nSpan);
					}

					li.appendChild(span);
					ol.appendChild(li);
				}
				wrapper.appendChild(ol);
			}
			leaderboardContainer.appendChild(wrapper);
		} catch (e) {
			// If API is unavailable, just show the score
			const p = document.createElement("p");
			p.textContent = `Final Score: ${score}`;
			p.style.textAlign = "center";
			leaderboardContainer.appendChild(p);
		}
	}

	function draw() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		if (!gameOver) ship.draw(ctx);
		for (const bullet of bullets) bullet.draw(ctx);
		for (const asteroid of asteroids) asteroid.draw(ctx);
	}

	function handleKeyUp(event: KeyboardEvent) {
		ship.handleUserInput(event, "up");
	}
	function handleKeyDown(event: KeyboardEvent) {
		ship.handleUserInput(event, "down");
	}

	class Ship {
		position: [number, number];
		direction: number;
		velocity: [number, number];
		addBulletFn: (b: Bullet) => void;
		maxSpeed = 4;
		acceleration = 0.15;
		deceleration = 0.995;
		turnSpeed = Math.PI / 30;
		size = 12;
		shotCoolDownTime = 15;
		isAccelerating = false;
		isTurningLeft = false;
		isTurningRight = false;
		isShooting = false;
		shotCounter = 0;
		isActive = true;
		keyActions: Record<number, string> = {
			37: "LEFT",
			38: "ACCELERATE",
			39: "RIGHT",
			65: "LEFT",
			87: "ACCELERATE",
			68: "RIGHT",
			32: "SHOOT",
		};

		constructor(initPosition: [number, number], addBulletFn: (b: Bullet) => void) {
			this.position = initPosition;
			this.direction = (3 * Math.PI) / 2;
			this.velocity = [0, 0];
			this.addBulletFn = addBulletFn;
		}

		update(xMax: number, yMax: number) {
			if (!this.isActive) return;
			this.move(xMax, yMax);
			if (this.isAccelerating) this.accelerate();
			if (this.isTurningLeft) this.turnLeft();
			if (this.isTurningRight) this.turnRight();
			this.shotCounter = Math.max(this.shotCounter - 1, 0);
			if (this.isShooting && this.shotCounter === 0) this.shoot();
		}

		move(xMax: number, yMax: number) {
			this.position[0] = (this.position[0] + this.velocity[0] + xMax) % xMax;
			this.position[1] = (this.position[1] + this.velocity[1] + yMax) % yMax;
			this.velocity[0] *= this.deceleration;
			this.velocity[1] *= this.deceleration;
		}

		accelerate() {
			const speed = Math.sqrt(this.velocity[0] ** 2 + this.velocity[1] ** 2);
			if (speed < this.maxSpeed) {
				this.velocity[0] += this.acceleration * Math.cos(this.direction);
				this.velocity[1] += this.acceleration * Math.sin(this.direction);
			}
		}

		turnLeft() {
			this.direction = (this.direction - this.turnSpeed + 2 * Math.PI) % (2 * Math.PI);
		}
		turnRight() {
			this.direction = (this.direction + this.turnSpeed) % (2 * Math.PI);
		}

		shoot() {
			this.addBulletFn(new Bullet([...this.position] as [number, number], this.direction));
			this.shotCounter = this.shotCoolDownTime;
		}

		crash() {
			this.isActive = false;
		}

		handleUserInput(event: KeyboardEvent, type: string) {
			const action = this.keyActions[event.keyCode];
			const setTo = type === "down";
			switch (action) {
				case "ACCELERATE":
					this.isAccelerating = setTo;
					break;
				case "LEFT":
					this.isTurningLeft = setTo;
					break;
				case "RIGHT":
					this.isTurningRight = setTo;
					break;
				case "SHOOT":
					this.isShooting = setTo;
					break;
			}
		}

		draw(ctx: CanvasRenderingContext2D) {
			const fp = [
				this.position[0] + this.size * Math.cos(this.direction),
				this.position[1] + this.size * Math.sin(this.direction),
			];
			const bp1 = [
				this.position[0] + (this.size / 2) * Math.cos(this.direction + (2 * Math.PI) / 3),
				this.position[1] + (this.size / 2) * Math.sin(this.direction + (2 * Math.PI) / 3),
			];
			const bp2 = [
				this.position[0] + (this.size / 2) * Math.cos(this.direction - (2 * Math.PI) / 3),
				this.position[1] + (this.size / 2) * Math.sin(this.direction - (2 * Math.PI) / 3),
			];
			ctx.beginPath();
			ctx.moveTo(fp[0], fp[1]);
			ctx.lineTo(bp1[0], bp1[1]);
			ctx.lineTo(this.position[0], this.position[1]);
			ctx.lineTo(bp2[0], bp2[1]);
			ctx.lineTo(fp[0], fp[1]);
			if (this.isAccelerating) {
				const td = Math.atan2(
					(this.velocity[1] + this.size * Math.sin(this.direction)) / 2,
					(this.velocity[0] + this.size * Math.cos(this.direction)) / 2,
				);
				ctx.moveTo(this.position[0], this.position[1]);
				ctx.lineTo(this.position[0] - this.size * Math.cos(td), this.position[1] - this.size * Math.sin(td));
				ctx.moveTo(bp1[0], bp1[1]);
				ctx.lineTo(bp1[0] - (this.size / 2) * Math.cos(td), bp1[1] - (this.size / 2) * Math.sin(td));
				ctx.moveTo(bp2[0], bp2[1]);
				ctx.lineTo(bp2[0] - (this.size / 2) * Math.cos(td), bp2[1] - (this.size / 2) * Math.sin(td));
			}
			ctx.stroke();
		}
	}

	class Bullet {
		position: [number, number];
		speed = 10;
		velocity: [number, number];
		size = 1;
		isActive = true;

		constructor(initPosition: [number, number], direction: number) {
			this.position = initPosition;
			this.velocity = [this.speed * Math.cos(direction), this.speed * Math.sin(direction)];
		}

		update() {
			this.position[0] += this.velocity[0];
			this.position[1] += this.velocity[1];
		}
		hit() {
			this.isActive = false;
		}

		draw(ctx: CanvasRenderingContext2D) {
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.arc(this.position[0], this.position[1], this.size, 0, 2 * Math.PI);
			ctx.fill();
			ctx.stroke();
			ctx.lineWidth = 1;
		}
	}

	class Asteroid {
		position: [number, number];
		speed: number;
		velocity: [number, number];
		tier: number;
		size: number;
		score: number;
		isActive = true;

		constructor(initPosition: [number, number], direction: number, tier?: number) {
			this.position = initPosition;
			this.speed = Math.random() * 3 + 1;
			this.velocity = [this.speed * Math.cos(direction), this.speed * Math.sin(direction)];
			this.tier = tier || Math.ceil(Math.random() * 4);
			this.size = 10 * Math.pow(this.tier, 1.5);
			this.score = (5 - this.tier) * 100;
		}

		update() {
			this.position[0] += this.velocity[0];
			this.position[1] += this.velocity[1];
		}

		split(): Asteroid[] {
			this.isActive = false;
			if (this.tier > 1) {
				return Array(3)
					.fill(0)
					.map(() => new Asteroid([...this.position] as [number, number], Math.random() * 2 * Math.PI, this.tier - 1));
			}
			return [];
		}

		draw(ctx: CanvasRenderingContext2D) {
			ctx.beginPath();
			ctx.arc(this.position[0], this.position[1], this.size, 0, 2 * Math.PI);
			ctx.stroke();
		}
	}

	function getDistanceBetween(a: [number, number], b: [number, number]) {
		const dx = b[0] - a[0];
		const dy = b[1] - a[1];
		return Math.sqrt(dx ** 2 + dy ** 2);
	}

	playAgainBtn.addEventListener("click", reset);
	window.addEventListener("resize", resizeCanvas);
	window.addEventListener("keyup", handleKeyUp);
	window.addEventListener("keydown", handleKeyDown);

	resizeCanvas();
	reset();
	run();
</script>

<style>
	.score {
		position: absolute;
		top: 3rem;
		right: 1rem;
	}

	canvas {
		position: absolute;
		left: 0;
		top: var(--header-height);
	}

	.game-over {
		--width: 15rem;
		--height: 25rem;
		width: var(--width);
		height: var(--height);
		display: flex;
		flex-flow: column;
		justify-content: center;
		position: absolute;
		left: calc((100vw - var(--width)) / 2);
		top: calc((100vh - var(--height)) / 2);
		z-index: 100;
	}

	.game-over span.game-over-message {
		font-size: 1.5rem;
		margin-bottom: 0.25rem;
	}

	.game-over span {
		text-align: center;
		display: block;
	}

	.game-over button {
		width: 8rem;
		margin: 0 auto;
	}

	.focus-attractor {
		color: transparent;
		height: 0;
	}

	.leaderboard ol {
		list-style-type: none;
		padding: 0;
		margin: 1rem auto;
	}

	.leaderboard ol li > span {
		margin-bottom: 0.2rem;
		display: flex;
		flex-flow: row;
		justify-content: space-between;
	}

	.leaderboard ol li span,
	.leaderboard ol li input {
		font-size: 0.8rem;
	}

	.leaderboard ol li input {
		text-align: right;
		width: 3rem;
		padding: 0;
		background-color: transparent;
	}
</style>
