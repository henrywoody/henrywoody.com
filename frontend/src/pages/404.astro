---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Asteroids | Henry Woody">
	<main>
		<h1>404: Not Found</h1>

		<div id="asteroids-container">
			<span class="score" id="score-display">Score: 0</span>
			<canvas></canvas>

			<div class="game-over-menu" id="game-over-menu" style="display:none;">
				<div class="game-over-message">Game Over</div>

				<div class="game-over-menu__score-container">
					<div id="game-over-score">Score: 0</div>
					<strong id="new-high-score">New High Score!</strong>
				</div>

				<div id="leaderboard-container">
					<div class="leaderboard-label">Leaderboard</div>
					<table class="leaderboard-scores-table">
						<thead>
							<tr>
								<th>#</th>
								<th>Score</th>
								<th>Name</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>1.</td>
								<td>0</td>
								<td>NUL</td>
							</tr>
						</tbody>
					</table>
				</div>
				<button id="play-again-btn">Play Again?</button>
			</div>

			<input class="focus-attractor" id="focus-attractor" />
		</div>
	</main>
</Layout>

<script>
	import { getAsteroidsScores, postAsteroidsScore } from "../utilities/api";
	import { isDarkModeOn } from "../utilities/theme";

	const container = document.getElementById("asteroids-container")!;
	const canvas = container.querySelector("canvas")!;
	const ctx = canvas.getContext("2d")!;
	const scoreDisplay = document.getElementById("score-display")!;
	const gameOverMenu = document.getElementById("game-over-menu")!;
	const gameOverScoreEl = document.getElementById("game-over-score")!;
	const newHighScoreEl = document.getElementById("new-high-score")!;
	const leaderboardContainer = document.getElementById("leaderboard-container")!;
	const leaderboardScoresTableBody = document.querySelector(".leaderboard-scores-table tbody")!;
	const playAgainBtn = document.getElementById("play-again-btn")!;
	const focusAttractor = document.getElementById("focus-attractor") as HTMLInputElement;

	let gameOver = false;
	let score = 0;
	let time = 0;
	let ship: Ship;
	let bullets: Bullet[] = [];
	let asteroids: Asteroid[] = [];
	let xMin: number, xMax: number, yMin: number, yMax: number;

	function resizeCanvas() {
		canvas.width = window.innerWidth;
		const headerHeight = (document.querySelector(".header-bar") as HTMLElement | undefined)?.offsetHeight || 0;
		canvas.height = window.innerHeight - headerHeight;

		const boundaryExtension = 100;
		xMin = -boundaryExtension;
		xMax = canvas.width + boundaryExtension;
		yMin = -boundaryExtension;
		yMax = canvas.height + boundaryExtension;
	}

	function reset() {
		resizeCanvas();
		const middleOfCanvas: [number, number] = [canvas.width / 2, canvas.height / 2];
		ship = new Ship(middleOfCanvas, addBullet);
		bullets = [];
		asteroids = [];
		gameOver = false;
		score = 0;
		time = 0;
		scoreDisplay.textContent = "Score: 0";
		scoreDisplay.style.display = "";
		gameOverMenu.style.display = "none";
		newHighScoreEl.style.display = "none";
		leaderboardContainer.style.display = "none";
		leaderboardScoresTableBody.innerHTML = "";
		focusAttractor.focus();
		focusAttractor.blur();
	}

	function run() {
		update();
		draw();
		window.requestAnimationFrame(run);
	}

	function update() {
		const color = isDarkModeOn() ? "#ffffff" : "#333333";
		ctx.fillStyle = color;
		ctx.strokeStyle = color;

		ship.update(canvas.width, canvas.height);
		for (const bullet of bullets) {
			bullet.update();
		}
		for (const asteroid of asteroids) {
			asteroid.update();
		}
		removeOutOfBoundsObjects();
		makeRandomAsteroids();
		checkCollisions();
		removeInactiveObjects();

		if (!gameOver) {
			time++;
		}
	}

	function addBullet(bullet: Bullet) {
		bullets.push(bullet);
	}

	function makeRandomAsteroids() {
		const asteroidCreationProb = Math.log(Math.log(time)) * 0.008;
		if (Math.random() < asteroidCreationProb) {
			const numToCreate = Math.floor(Math.random() * 3) + 1;
			for (let i = 0; i < numToCreate; i++) {
				let position: [number, number], direction: number;
				const rand = Math.random();
				if (rand < 0.25) {
					position = [xMin, Math.random() * yMax];
					direction = Math.random() * Math.PI + Math.PI;
				} else if (rand < 0.5) {
					position = [xMax, Math.random() * yMax];
					direction = -1 * Math.random() * Math.PI - Math.PI;
				} else if (rand < 0.75) {
					position = [Math.random() * xMax, yMin];
					direction = Math.random() * Math.PI;
				} else {
					position = [Math.random() * xMax, yMax];
					direction = -1 * Math.random() * Math.PI;
				}
				asteroids.push(new Asteroid(position, direction));
			}
		}
	}

	function removeOutOfBoundsObjects() {
		const filterFunc = (e: { position: [number, number] }) => {
			const inXBounds = xMin <= e.position[0] && e.position[0] <= xMax;
			const inYBounds = yMin <= e.position[1] && e.position[1] <= yMax;
			return inXBounds && inYBounds;
		};
		bullets = bullets.filter(filterFunc);
		asteroids = asteroids.filter(filterFunc);
	}

	function checkCollisions() {
		if (!gameOver) checkShipAsteroidCollisions();
		checkBulletAsteroidCollisions();
	}

	function checkShipAsteroidCollisions() {
		for (const asteroid of asteroids) {
			const distance = getDistanceBetween(asteroid.position, ship.position);
			if (distance <= asteroid.size + ship.size / 2) {
				ship.crash();
				endGame();
				break;
			}
		}
	}

	function checkBulletAsteroidCollisions() {
		const newAsteroids: Asteroid[] = [];
		for (const bullet of bullets) {
			for (const asteroid of asteroids) {
				const distance = getDistanceBetween(asteroid.position, bullet.position);
				if (distance <= asteroid.size + bullet.size) {
					bullet.hit();
					newAsteroids.push(...asteroid.split());
					score += asteroid.score;
					scoreDisplay.textContent = `Score: ${score}`;
				}
			}
		}
		asteroids.push(...newAsteroids);
	}

	function removeInactiveObjects() {
		const filterFunc = (e: { isActive: boolean }) => e.isActive;
		bullets = bullets.filter(filterFunc);
		asteroids = asteroids.filter(filterFunc);
	}

	function endGame() {
		gameOver = true;
		scoreDisplay.style.display = "none";
		gameOverScoreEl.textContent = `Score: ${score}`;
		gameOverMenu.style.display = "";
		buildLeaderboard();
	}

	async function buildLeaderboard() {
		const scoreCount = 10;
		try {
			const highScores = await getAsteroidsScores(scoreCount);

			leaderboardContainer.style.display = "";
			let displayScores = [...highScores];
			let isNewHighScore = false;

			if (highScores.length && score > highScores[highScores.length - 1].score) {
				isNewHighScore = true;
				let insertIndex = 0;
				if (score <= highScores[0].score) {
					for (let i = highScores.length - 1; i >= 0; i--) {
						if (highScores[i].score >= score) {
							insertIndex = i + 1;
							break;
						}
					}
				}
				displayScores.splice(insertIndex, 0, { score, name: "$this" });
				if (displayScores.length > scoreCount) {
					displayScores.pop();
				}
			} else if (highScores.length < scoreCount && score > 0) {
				isNewHighScore = true;
				displayScores.push({ score, name: "$this" });
			}

			gameOverScoreEl.textContent = `Score: ${score}`;
			if (isNewHighScore) {
				newHighScoreEl.style.display = "block";
			}

			leaderboardScoresTableBody.innerHTML = "";
			if (displayScores.length) {
				let playerName = "";
				let scoreWasPosted = false;

				for (let i = 0; i < displayScores.length; i++) {
					const hs = displayScores[i];
					const row = document.createElement("tr");

					if (hs.name === "$this") {
						const rankCell = document.createElement("td");
						rankCell.textContent = `${i + 1}.`;
						row.appendChild(rankCell);

						const scoreCell = document.createElement("td");
						scoreCell.textContent = String(hs.score);
						row.appendChild(scoreCell);

						const form = document.createElement("form");
						const input = document.createElement("input");
						input.type = "text";
						input.size = 3;
						input.maxLength = 3;
						input.addEventListener("input", () => {
							playerName = input.value.toUpperCase();
							input.value = playerName;
						});
						form.addEventListener("submit", async (e) => {
							e.preventDefault();
							if (!scoreWasPosted) {
								await postAsteroidsScore(playerName, score);
								scoreWasPosted = true;
								input.readOnly = true;
							}
						});
						form.appendChild(input);
						const nameCell = document.createElement("td");
						nameCell.appendChild(form);
						row.appendChild(nameCell);
						requestAnimationFrame(() => input.focus());
					} else {
						const rankCell = document.createElement("td");
						rankCell.textContent = `${i + 1}.`;
						row.appendChild(rankCell);

						const scoreCell = document.createElement("td");
						scoreCell.textContent = String(hs.score);
						row.appendChild(scoreCell);

						const nameCell = document.createElement("td");
						nameCell.textContent = String(hs.name);
						row.appendChild(nameCell);
					}

					leaderboardScoresTableBody.appendChild(row);
				}
			}
		} catch (e) {
			leaderboardContainer.style.display = "none";
		}
	}

	function draw() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		if (!gameOver) {
			ship.draw(ctx);
		}
		for (const bullet of bullets) bullet.draw(ctx);
		for (const asteroid of asteroids) asteroid.draw(ctx);
	}

	function handleKeyUp(event: KeyboardEvent) {
		ship.handleUserInput(event, "up");
	}
	function handleKeyDown(event: KeyboardEvent) {
		ship.handleUserInput(event, "down");
	}

	class Ship {
		position: [number, number];
		direction: number;
		velocity: [number, number];
		addBulletFn: (b: Bullet) => void;
		acceleration = 0.3;
		deceleration = 0.999;
		turnSpeed = Math.PI / 30;
		size = 12;
		shotCoolDownTime = 15;
		isAccelerating = false;
		isTurningLeft = false;
		isTurningRight = false;
		isShooting = false;
		shotCounter = 0;
		isActive = true;
		keyActions: Record<number, string> = {
			37: "LEFT",
			38: "ACCELERATE",
			39: "RIGHT",
			65: "LEFT",
			87: "ACCELERATE",
			68: "RIGHT",
			32: "SHOOT",
		};

		constructor(initPosition: [number, number], addBulletFn: (b: Bullet) => void) {
			this.position = initPosition;
			this.direction = (3 * Math.PI) / 2;
			this.velocity = [0, 0];
			this.addBulletFn = addBulletFn;
		}

		update(xMax: number, yMax: number) {
			if (!this.isActive) return;
			this.move(xMax, yMax);
			if (this.isAccelerating) this.accelerate();
			if (this.isTurningLeft) this.turnLeft();
			if (this.isTurningRight) this.turnRight();
			this.shotCounter = Math.max(this.shotCounter - 1, 0);
			if (this.isShooting && this.shotCounter === 0) this.shoot();
		}

		move(xMax: number, yMax: number) {
			this.position[0] = (this.position[0] + this.velocity[0] + xMax) % xMax;
			this.position[1] = (this.position[1] + this.velocity[1] + yMax) % yMax;
			this.velocity[0] *= this.deceleration;
			this.velocity[1] *= this.deceleration;
		}

		accelerate() {
			this.velocity[0] += this.acceleration * Math.cos(this.direction);
			this.velocity[1] += this.acceleration * Math.sin(this.direction);
		}

		turnLeft() {
			this.direction = (this.direction - this.turnSpeed + 2 * Math.PI) % (2 * Math.PI);
		}
		turnRight() {
			this.direction = (this.direction + this.turnSpeed) % (2 * Math.PI);
		}

		shoot() {
			this.addBulletFn(new Bullet([...this.position], [...this.velocity], this.direction));
			this.shotCounter = this.shotCoolDownTime;
		}

		crash() {
			this.isActive = false;
		}

		handleUserInput(event: KeyboardEvent, type: string) {
			const action = this.keyActions[event.keyCode];
			const setTo = type === "down";
			switch (action) {
				case "ACCELERATE":
					this.isAccelerating = setTo;
					break;
				case "LEFT":
					this.isTurningLeft = setTo;
					break;
				case "RIGHT":
					this.isTurningRight = setTo;
					break;
				case "SHOOT":
					this.isShooting = setTo;
					break;
			}
		}

		draw(ctx: CanvasRenderingContext2D) {
			const fp = [
				this.position[0] + this.size * Math.cos(this.direction),
				this.position[1] + this.size * Math.sin(this.direction),
			];
			const bp1 = [
				this.position[0] + (this.size / 2) * Math.cos(this.direction + (2 * Math.PI) / 3),
				this.position[1] + (this.size / 2) * Math.sin(this.direction + (2 * Math.PI) / 3),
			];
			const bp2 = [
				this.position[0] + (this.size / 2) * Math.cos(this.direction - (2 * Math.PI) / 3),
				this.position[1] + (this.size / 2) * Math.sin(this.direction - (2 * Math.PI) / 3),
			];
			ctx.beginPath();
			ctx.moveTo(fp[0], fp[1]);
			ctx.lineTo(bp1[0], bp1[1]);
			ctx.lineTo(this.position[0], this.position[1]);
			ctx.lineTo(bp2[0], bp2[1]);
			ctx.lineTo(fp[0], fp[1]);
			if (this.isAccelerating) {
				const td = Math.atan2(
					(this.velocity[1] + this.size * Math.sin(this.direction)) / 2,
					(this.velocity[0] + this.size * Math.cos(this.direction)) / 2,
				);
				ctx.moveTo(this.position[0], this.position[1]);
				ctx.lineTo(this.position[0] - this.size * Math.cos(td), this.position[1] - this.size * Math.sin(td));
				ctx.moveTo(bp1[0], bp1[1]);
				ctx.lineTo(bp1[0] - (this.size / 2) * Math.cos(td), bp1[1] - (this.size / 2) * Math.sin(td));
				ctx.moveTo(bp2[0], bp2[1]);
				ctx.lineTo(bp2[0] - (this.size / 2) * Math.cos(td), bp2[1] - (this.size / 2) * Math.sin(td));
			}
			ctx.stroke();
		}
	}

	class Bullet {
		position: [number, number];
		speed = 10;
		velocity: [number, number];
		size = 1;
		isActive = true;

		constructor(initPosition: [number, number], initVelocity: [number, number], direction: number) {
			this.position = initPosition;
			this.velocity = [
				initVelocity[0] + this.speed * Math.cos(direction),
				initVelocity[1] + this.speed * Math.sin(direction),
			];
		}

		update() {
			this.position[0] += this.velocity[0];
			this.position[1] += this.velocity[1];
		}

		hit() {
			this.isActive = false;
		}

		draw(ctx: CanvasRenderingContext2D) {
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.arc(this.position[0], this.position[1], this.size, 0, 2 * Math.PI);
			ctx.fill();
			ctx.stroke();
			ctx.lineWidth = 1;
		}
	}

	class Asteroid {
		position: [number, number];
		speed: number;
		velocity: [number, number];
		tier: number;
		size: number;
		score: number;
		isActive = true;

		constructor(initPosition: [number, number], direction: number, tier?: number) {
			this.position = initPosition;
			this.speed = Math.random() * 3 + 1;
			this.velocity = [this.speed * Math.cos(direction), this.speed * Math.sin(direction)];
			this.tier = tier || Math.ceil(Math.random() * 4);
			this.size = 10 * Math.pow(this.tier, 1.5);
			this.score = (5 - this.tier) * 100;
		}

		update() {
			this.position[0] += this.velocity[0];
			this.position[1] += this.velocity[1];
		}

		split(): Asteroid[] {
			this.isActive = false;
			if (this.tier > 1) {
				return Array(3)
					.fill(0)
					.map(() => new Asteroid([...this.position] as [number, number], Math.random() * 2 * Math.PI, this.tier - 1));
			}
			return [];
		}

		draw(ctx: CanvasRenderingContext2D) {
			ctx.beginPath();
			ctx.arc(this.position[0], this.position[1], this.size, 0, 2 * Math.PI);
			ctx.stroke();
		}
	}

	function getDistanceBetween(a: [number, number], b: [number, number]) {
		const dx = b[0] - a[0];
		const dy = b[1] - a[1];
		return Math.sqrt(dx ** 2 + dy ** 2);
	}

	playAgainBtn.addEventListener("click", reset);
	window.addEventListener("resize", resizeCanvas);
	window.addEventListener("keyup", handleKeyUp);
	window.addEventListener("keydown", handleKeyDown);

	resizeCanvas();
	reset();
	run();
</script>

<style>
	.score {
		position: absolute;
		top: 3rem;
		right: 1rem;
	}

	canvas {
		position: absolute;
		left: 0;
		top: var(--header-height);
	}

	.game-over-menu {
		background-color: color-mix(in srgb, var(--background-color) 85%, transparent);

		padding: 2rem;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		gap: 1rem;

		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		z-index: 100;
	}

	.game-over-menu .game-over-message {
		font-size: 1.5rem;
		margin-bottom: 0.25rem;
	}

	.game-over-menu span {
		text-align: center;
		display: block;
	}

	.game-over-menu button {
		width: 8rem;
		margin: 0 auto;
	}

	.game-over-menu__score-container {
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 0.25rem;
	}

	.leaderboard-label {
		text-align: center;
		display: block;
	}

	.leaderboard-scores-table {
		list-style-type: none;
		padding: 0;
		margin: 0 auto;
	}

	:global(.leaderboard-scores-table :is(th, td)) {
		padding: 0.125rem 0.5rem;
	}

	.leaderboard-scores-table,
	:global(.leaderboard-scores-table input) {
		font-size: 0.875rem;
	}

	:global(.leaderboard-scores-table input) {
		width: 3rem;
		padding: 0;
		background-color: transparent;
	}

	.focus-attractor {
		color: transparent;
		height: 0;
	}
</style>
